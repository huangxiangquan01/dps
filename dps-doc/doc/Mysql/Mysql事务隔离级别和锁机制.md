# 事务及其ACID属性
事务是由一组SQL语句组成的逻辑处理单元,事务具有以下4个属性,通常简称为事务的ACID属性。
    - 原子性(Atomicity) ：事务是一个原子操作单元,其对数据的修改,要么全都执行,要么全都不执行。 
    - 一致性(Consistent) ：在事务开始和完成时,数据都必须保持一致状态。这意味着所有相关的数据规 则都必须应用于事务的修改,以保持数据的完整性。 
    - 隔离性(Isolation) ：数据库系统提供一定的隔离机制,保证事务在不受外部并发操作影响的“独 立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的,反之亦然。 
    - 持久性(Durable) ：事务完成之后,它对于数据的修改是永久性的,即使出现系统故障也能够保持。
 
### 并发事务处理带来的问题
1. 脏读（Dirty Reads）
    **事务A读取到了事务B已经修改但尚未提交的数据**

1. 不可重读（Non-Repeatable Reads）
    **事务A内部的相同查询语句在不同时刻读出的结果不一致，不符合隔离性**

1. 幻读（Phantom Reads）
    **事务A读取到了事务B提交的新增数据，不符合隔离性**

### 事务隔离级别
“脏读”、“不可重复读”和“幻读”,其实都是数据库读一致性问题,必须由数据库提供一定的事务隔离机制 来解决。

|  隔离级别   |  脏读（Dirty Reads）   |  不可重读（Non-Repeatable Reads）   |  幻读（Phantom Reads）  |
|  :----     |    :-----             |   :-----               |   :-----                 |
|  读未提交   |  可能   |   可能  |  可能  |
|  读已提交   |  不可能   |   可能  |  可能  |
|  可重复读   |  不可能   |   不可能  |  可能  |
|  可串行化   |  不可能   |   不可能  |  不可能  |

数据库的事务隔离越严格,并发副作用越小,但付出的代价也就越大,因为事务隔离实质上就是使事务在一定程度 上“串行化”进行,这显然与“并发”是矛盾的。 同时,不同的应用对读一致性和事务隔离程度的要求也是不同的,比如许多应用对“不可重复读"和“幻读”并不 敏感,可能更关心数据并发访问的能力。

**常看当前数据库的事务隔离级别: show variables like 'tx_isolation';**
**设置事务隔离级别：set tx_isolation='REPEATABLE-READ';**

Mysql默认的事务隔离级别是可重复读，用Spring开发程序时，如果不设置隔离级别默认用Mysql设置的隔 离级别，如果Spring设置了就用已经设置的隔离级别

# 锁详解

### 锁分类

   > 从性能上分为乐观锁(用版本对比来实现)和悲观锁 
   >
   > 从对数据库操作的类型分，分为读锁和写锁(都属于悲观锁) 
   > > 读锁（共享锁，S锁(Shared)）：针对同一份数据，多个读操作可以同时进行而不会互相影响 
   >
   > > 写锁（排它锁，X锁(eXclusive)）：当前写操作没有完成前，它会阻断其他写锁和读锁 
   >
   > 从对数据操作的粒度分，分为表锁和行锁

###  表锁
每次操作锁住整张表。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低； 一般用在整表数据迁移的场景。

- 手动增加表锁 
    > lock table 表名称 read(write),表名称2 read(write); 
- 查看表上加过的锁 
    > show open tables;
- 删除表锁 
    > unlock tables;
#### 案例结论
1. 对MyISAM表的读操作(加读锁) ,不会阻寒其他进程对同一表的读请求,但会阻赛对同一表的写请求。只有当 读锁释放后,才会执行其它进程的写操作。 
2. 对MylSAM表的写操作(加写锁) ,会阻塞其他进程对同一表的读和写操作,只有当写锁释放后,才会执行其它进 程的读写操作

### 行锁
每次操作锁住一行数据。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度最高。

InnoDB与MYISAM的最大不同有两点： 
   - InnoDB支持事务（TRANSACTION）
   - InnoDB支持行级锁
   
#### 行锁演示
一个session开启事务更新不提交，另一个session更新同一条记录会阻塞，更新不同记录不会阻塞

#### 总结
MyISAM在执行查询语句SELECT前，会自动给涉及的所有表加读锁,在执行update、insert、delete操作会自 动给涉及的表加写锁。 InnoDB在执行查询语句SELECT时(非串行隔离级别)，不会加锁。但是update、insert、delete操作会加行 锁。简而言之，就是读锁会阻塞写，但是不会阻塞读。而写锁则会把读和写都阻塞。

### 间隙锁(Gap Lock)
间隙锁，锁的就是两个值之间的空隙。Mysql默认级别是repeatable-read，有办法解决幻读问题吗？间隙锁 在某些情况下可以解决幻读问题。
  
    其他Session没法在这个范围所包含的所有行记录(包括间隙行记录)以及行记录所在的间隙里插入或修改任何数据, 间隙锁是在可重复读隔离级别下才会生效。

### 临键锁(Next-key Locks)
Next-Key Locks是行锁与间隙锁的组合。像上面那个例子里的这个(3,20]的整个区间可以叫做临键锁。

#### 无索引行锁会升级为表锁
锁主要是加在索引上，如果对非索引字段更新，行锁可能会变表锁
   - session1 执行：update account set balance = 800 where name = 'lilei'; 
   - session2 对该表任一行操作都会阻塞住 
   - InnoDB的行锁是针对索引加的锁，不是针对记录加的锁。并且该索引不能失效，否则都会从行锁升级为 表锁。  
   
> Innodb存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更 高一下，但是在整体并发处理能力方面要远远优于MYISAM的表级锁定的。当系统并发量高的时候，Innodb 的整体性能和MYISAM相比就会有比较明显的优势了。 但是，Innodb的行级锁定同样也有其脆弱的一面，当我们使用不当的时候，可能会让Innodb的整体性能表现 不仅不能比MYISAM高，甚至可能会更差。

#### 行锁分析
通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况
    >  show status like 'innodb_row_lock%';  
    
1. Innodb_row_lock_current_waits: 当前正在等待锁定的数量 
1. Innodb_row_lock_time: 从系统启动到现在锁定总时间长度 
1. Innodb_row_lock_time_avg: 每次等待所花平均时间 
1. Innodb_row_lock_time_max：从系统启动到现在等待最长的一次所花时间    

### 死锁
set tx_isolation='repeatable-read'; 
1. Session_1执行：select * from account where id=1 for update; 
1. Session_2执行：select * from account where id=2 for update; 
1. Session_1执行：select * from account where id=2 for update; 
1. Session_2执行：select * from account where id=1 for update; 

查看近期死锁日志信息：show engine innodb status\G; 大多数情况mysql可以自动检测死锁并回滚产生死锁的那个事务，但是有些情况mysql没法自动检测死锁

### 锁优化建议
   - 尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁合理设计索引，
   - 尽量缩小锁的范围 
   - 尽可能减少检索条件范围，避免间隙锁
   - 尽量控制事务大小，减少锁定资源量和时间长度，涉及事务加锁的sql尽量放在事务最后执行 
   - 尽可能低级别事务隔离
